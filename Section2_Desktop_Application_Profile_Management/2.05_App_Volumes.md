# 2.5 App Volumesによるアプリケーション配信

## 試験ガイド対応 (Section 4.2 — OCA知識前提)

- App Volumesのアーキテクチャと配信モデル
- Application / Package / Program の階層構造
- パッケージング手順（Management Console方式）
- Marker（CURRENT）とPackage Lifecycle
- Assignment（ユーザー/グループ/マシンへの割り当て）
- Delivery Mode（Classic vs On-Demand）

---

## 1. App Volumesのアーキテクチャ

### 1.1 App Volumesとは

App Volumesは、アプリケーションを仮想ディスク（VMDK）にパッケージ化し、ユーザーセッションに動的にアタッチする技術である。Golden Imageにアプリケーションを含めずに済むため、イメージ管理の簡素化とアプリケーション配信の柔軟性を実現する。

### 1.2 主要コンポーネント

| コンポーネント | 役割 |
|--------------|------|
| App Volumes Manager | 管理サーバー（Webコンソール、API、スケジューリング） |
| App Volumes Agent | VM上のエージェント（パッケージのアタッチ/デタッチ） |
| App Volumes Package | アプリケーションを格納した仮想ディスク（VMDK） |
| Packaging VM | アプリケーションキャプチャ用のVM |
| Storage | パッケージ格納先（vSphere Datastore / SMBファイル共有） |

### 1.3 App Volumes 4.x の階層構造

App Volumes 4.x では、以下の3層の階層構造でアプリケーションを管理する:

```
Application（アプリケーション）
  └── Package（パッケージ = VMDKディスク）
        └── Program（プログラム = 実行可能なアプリ）
```

| 階層 | 説明 | 例 |
|------|------|-----|
| Application | アプリケーションの論理的なグループ | 「Notepad++」「Microsoft Office 2021」 |
| Package | 特定バージョンのキャプチャ済みVMDK | 「Notepad++ v8.6.0」「Notepad++ v8.5.0」 |
| Program | パッケージ内の個別実行可能プログラム | 「notepad++.exe」 |

> **試験ポイント**: Application → Package → Program の3層構造を理解することが重要。1つのApplicationに複数のPackage（バージョン違い）を持ち、CURRENTマーカーでデフォルト配信バージョンを指定する。

---

### 1.4 App Volumes Managerのロール

| ロール | 権限 |
|-------|------|
| App Volumes Administrators | すべての管理操作（パッケージング、Assignment、設定変更） |
| Application Administrators | アプリケーション管理のみ（パッケージング、Assignment） |
| Read Only Administrators | 読み取り専用 |

---

## 2. パッケージング手順（Management Console方式）

### 2.1 パッケージングの3ステップワークフロー

公式ドキュメントでは **Prepare → Create → Validate** の3ステップが定義されている。

### 2.2 Step 1: Prepare（準備）

#### Packaging VMの準備

| 要件 | 説明 |
|------|------|
| OS | Golden Imageと同一のWindows OSバージョン |
| App Volumes Agent | インストール済み、App Volumes Managerに登録済み |
| Horizon Agent | **不要**（Packaging VM専用。VDI Agentは不要） |
| DEM FlexEngine | **不要**（パッケージング時には不要） |
| 状態 | クリーンな状態（スナップショットで復元可能） |
| 電源 | **ON** 状態（Agent通信が必要） |

> **試験ポイント**: Packaging VMにはApp Volumes Agentのみが必須。Horizon AgentやDEM Agentは不要。パッケージング後はスナップショットに戻して次のキャプチャに備える。

### 2.3 Step 2: Create（作成）

#### 2.3.1 ApplicationとPackageの作成

1. App Volumes Manager Console > **INVENTORY > Applications** > **Create**
2. Application名を入力（例: `Notepad++`）
3. Package作成画面で以下を入力:
   - **Package Name**: バージョン識別名（例: `v8.6.0`）
   - **Delivery Mode**: Classic / On Demand
   - **Storage**: パッケージ保存先のDatastore / SMB Share

#### 2.3.2 Packaging VM へのパッケージ割り当て

1. 作成したPackage > **Package** ボタン
2. Packaging VMのホスト名で検索
3. **Start Packaging** をクリック
4. Package Status が **Unpackaged → Packaging** に変化

この時点で、App Volumesは空のVMDKディスクを作成しPackaging VMにアタッチする。

#### 2.3.3 アプリケーションのインストールとキャプチャ

1. Packaging VMにログイン
2. App Volumes Agentのポップアップで「Ready to install」を確認
3. 対象アプリケーションをインストール
4. アプリケーションの動作確認
5. **重要**: アプリケーションのショートカットは `C:\Users\Public\Desktop` に配置
   - ユーザープロファイル内のショートカットはキャプチャされない
6. インストーラファイルを削除（キャプチャに含めないため）
7. App Volumes Agentのポップアップで **OK** → **Yes** でキャプチャ完了
8. **Finalize** をクリック → VMが再起動 → スナップショットに復元

> **試験ポイント**: アプリケーションのショートカットアイコンがユーザーのプロファイル配下（`%APPDATA%`）にある場合、App Volumesパッケージにキャプチャされない。`C:\Users\Public\Desktop` またはProgram Files配下に配置する必要がある。

#### 2.3.4 Markerの設定（CURRENT）

パッケージング完了後、Status が **Packaging → Enabled** に変化する。

1. INVENTORY > Packages > 対象Package
2. **Set CURRENT** をクリック
3. Packageに **CURRENT** タグが付与される

**CURRENTマーカーの意味**:
- Assignment Type: Marker でアサインされたユーザーに対して、CURRENTマーカーが付いたPackageが配信される
- 新バージョンのPackageにCURRENTを移動すると、次回ログイン時に自動的に新バージョンが配信される

### 2.4 Step 3: Validate（検証）

1. テスト用VDI VMにログイン
2. App Volumes Agentがパッケージをアタッチすることを確認
3. アプリケーションが正常に起動・動作することを確認
4. ショートカットが表示されていることを確認

---

## 3. Assignment（割り当て）

### 3.1 Assignment対象

| 対象 | 説明 |
|------|------|
| User | ADユーザーに個別割り当て |
| Group | ADグループに割り当て（推奨） |
| Computer | 特定のマシンに割り当て |
| OU | ADのOUに割り当て |

### 3.2 Assignment Type

| タイプ | 動作 |
|-------|------|
| **Marker** | CURRENTマーカーが付いたPackageを自動配信。バージョン切替が容易 |
| **Package** | 特定のPackage（バージョン）を固定配信。テストや旧バージョン維持に使用 |

> **試験ポイント**: 通常運用では **Marker** タイプを使用する。CURRENTマーカーを新バージョンに移動するだけで、全対象ユーザーに新バージョンが自動配信される。特定ユーザーだけ旧バージョンを維持する場合は **Package** タイプで固定する。

### 3.3 Assignment手順

1. INVENTORY > Applications > 対象Application
2. **Assign** をクリック
3. ADからユーザー/グループを検索・選択
4. Assignment Type を選択（Marker / Package）
5. **Assign** で確定

---

## 4. Delivery Mode（配信モード）

### 4.1 Classic vs On-Demand

| 項目 | Classic | On Demand |
|------|---------|-----------|
| アタッチタイミング | ログイン時 | アプリケーション起動時 |
| ログイン時間への影響 | パッケージ数に比例して増加 | 影響なし |
| アプリ起動遅延 | なし | 初回起動時にわずかな遅延 |
| リソース消費 | ログイン時に全パッケージマウント | 必要時のみマウント |
| 推奨ユースケース | 常時使用するアプリ | たまに使用するアプリ、大規模アプリ |

### 4.2 Delivery Modeの設定

Package作成時に選択する。作成後の変更はできないため、設計時に決定する必要がある。

---

## 5. Package Lifecycle（ライフサイクル管理）

### 5.1 Packageのステータス遷移

```
Unpackaged → Packaging → Enabled → CURRENT → (新バージョン作成時) Enabled → Disabled
```

| ステータス | 説明 |
|-----------|------|
| Unpackaged | 空のPackage（VMDKなし） |
| Packaging | キャプチャ中 |
| Enabled | キャプチャ完了、配信可能 |
| CURRENT | デフォルト配信バージョン（Marker Assignment用） |
| Disabled | 配信停止 |

### 5.2 バージョン更新のワークフロー

1. 同一Application配下に新しいPackageを作成
2. Packaging VMで新バージョンのアプリをキャプチャ
3. 新PackageにCURRENTマーカーを設定
4. 旧Packageは自動的にCURRENTから外れる（Enabled状態に戻る）
5. Marker Assignmentのユーザーは次回ログイン時に新バージョンを受け取る
6. 問題があれば旧PackageにCURRENTを戻す（ロールバック）

> **試験ポイント**: CURRENTマーカーの移動だけでバージョン更新・ロールバックが可能。Golden Imageの更新やPush Imageは不要。これがApp Volumesの最大の運用メリットである。

---

## 6. ストレージとレプリケーション

### 6.1 ストレージ構成

| ストレージタイプ | 説明 |
|---------------|------|
| vSphere Datastore | ESXiホストからアクセスするVMFS/vSANデータストア |
| SMB File Share | UNCパスでアクセスするファイル共有（ネットワークストレージ） |

### 6.2 Storage Group

複数のDatastoreをグループ化し、パッケージ配信時の可用性と負荷分散を実現する。

### 6.3 レプリケーション

複数サイト・複数Datastoreにパッケージを複製する機能。

**設定手順**:
1. App Volumes Manager > Configuration > Storage
2. Replication Partner を追加
3. レプリケーションスケジュールを設定（即座 / スケジュール）

**ストレージ容量計算**:
```
必要容量 = パッケージ数 × 平均パッケージサイズ × レプリカ数
```

---

## 7. Writable Volumes（書き込み可能ボリューム）

### 7.1 Writable Volumeとは

Writable Volumeは、ユーザーが個人的にインストールしたアプリケーションやデータを永続的に保持するための仮想ディスクである。Instant Clone（非永続）環境でユーザーのパーソナルデータを維持するために使用する。

### 7.2 Writable Volumeの種類

| タイプ | 説明 | ユースケース |
|-------|------|------------|
| User Writable Volume | ユーザーがインストールしたアプリ + プロファイルデータ | 個人アプリのインストール |
| User Profile Only | ユーザープロファイルデータのみ | プロファイル永続化（DEMの代替） |

### 7.3 Writable Volumeの作成

1. App Volumes Manager > VOLUMES > Writable > **Create**
2. 対象ユーザー/グループを検索して選択
3. サイズを指定（デフォルト: 10 GB）
4. 保存先Datastoreを選択
5. **Create** で確定

### 7.4 Writable Volume Exclusions

特定のフォルダやレジストリキーをWritable Volumeの書き込み対象から除外できる。

| 設定 | 説明 |
|------|------|
| Folder Exclusions | 指定フォルダへの書き込みをWritable Volumeに保存しない |
| Registry Exclusions | 指定レジストリキーの変更をWritable Volumeに保存しない |

### 7.5 Writable Volume vs DEM Profile Archive

| 比較項目 | Writable Volume | DEM Profile Archive |
|---------|----------------|-------------------|
| 保存対象 | アプリ + プロファイル全体 | Flex Config定義済みの設定のみ |
| サイズ | 大きい（GB単位） | 小さい（MB単位） |
| 管理の粒度 | 粗い（ディスク全体） | 細かい（アプリ設定単位） |
| 推奨 | 特殊ケースのみ | ✅ 標準推奨 |

> **試験ポイント**: Writable Volumeはユーザーが自分でアプリをインストールする必要がある場合に使用する。プロファイル管理のみが目的であればDEMを使用するのがベストプラクティス。Writable VolumeはDEMよりストレージコストが高く、管理が複雑になる。

---

## 8. CLI方式のパッケージング（App Volumes Tools）

### 8.1 appcapture.exe によるパッケージング

App Volumes Manager Consoleに加えて、コマンドライン（CLI）でもパッケージングが可能。App Volumes Toolsの `appcapture.exe` を使用する。

#### 主要コマンド

| コマンド | 説明 |
|---------|------|
| `appcapture.exe /new <Name> /d "<Desc>"` | 新規パッケージのキャプチャ開始。VHDファイルを作成 |
| `appcapture.exe /end` | キャプチャ終了。VMが再起動される |
| `appcapture.exe /test <path.vhd>` | キャプチャ済みVHDのテストマウント |

#### CLI方式の出力ファイル

| ファイル | 説明 |
|---------|------|
| `<Name>.vhd` | アプリケーションパッケージ本体（VHD形式） |
| `<Name>.json` | パッケージメタデータ（プログラム情報等） |
| `<Name>.vmdk` | VMDK形式（vSphere環境向け）|

> **試験ポイント**: CLI方式はAutomationやCI/CDパイプラインとの統合に適する。出力VHD/VMDKとJSONファイルをApp Volumes Managerにアップロードして配信する。

---

## 9. ThinAppパッケージのApp Volumes統合

### 9.1 ThinAppの位置づけ

ThinAppはOmnissaのアプリケーション仮想化ツールであるが、現在はApp Volumesへの統合・移行が推奨されている。既存のThinAppパッケージはApp Volumesで配信可能。

### 9.2 ThinAppパッケージの配信方法

ThinAppパッケージをApp Volumesでキャプチャする2つの方法:

| 方法 | 説明 | ThinAppの配置 |
|------|------|-------------|
| Method 1: MSI/EXE方式（分散配置） | ThinAppのMSI/EXEインストーラをApp Volumesキャプチャ中にインストール | ローカルにインストール |
| Method 2: ThinReg.exe方式（集中配置） | `ThinReg.exe` でリモート共有からThinAppを登録 | リモート共有からストリーミング |

#### Method 1の手順

1. `appcapture.exe /new` でキャプチャ開始
2. ThinAppのMSIインストーラを実行
3. アプリケーションの動作確認
4. `appcapture.exe /end` でキャプチャ終了

#### Method 2の手順

1. `appcapture.exe /new` でキャプチャ開始
2. `ThinReg.exe "\\share\ThinApps\App.exe" /a` でリモート共有から登録
3. アプリケーションの動作確認
4. `appcapture.exe /end` でキャプチャ終了

### 9.3 ThinAppとネイティブアプリの共存

App Volumesパッケージ内にThinApp版（レガシー）とネイティブインストール版（最新）の同一アプリケーションを共存させることが可能。

> **試験ポイント**: ThinAppパッケージのApp Volumes統合は、レガシーアプリケーションの移行パスとして出題される。Microsoft App-Vからの移行にも `appcapture.exe` を使用してApp Volumesパッケージに変換できる（App Volumes 2410以降）。

---

## 10. MSIX対応とMSI Wrapping

### 10.1 App Volumes 2412の新機能

| 機能 | 説明 |
|------|------|
| MSI for Windows Endpoints | VHDパッケージをMSIでラッピングし、物理Windowsエンドポイントへの配信をサポート |
| App GUIDパラメータ | キャプチャ/インポート時にGUIDを指定し、パッケージを自動グループ化 |
| Azure Virtual Desktop連携強化 | AVD App Attachでのキーバリューペアタグ付けをサポート |

### 10.2 MSI Wrapped VHDの配信フロー

```
App Volumes Package (VHD)
  ↓ MSI Wrapping
  ↓ Workspace ONE UEM 等の配信インフラ経由
  ↓ 物理Windows PCに配信
  ↓ App Volumes Agentがローカルでアタッチ
```

> **試験ポイント**: App Volumes 2412以降、MSI Wrapped VHDにより物理Windowsエンドポイントへのアプリ配信も可能になった。従来のVDI/RDSH環境だけでなく、物理PCへのユースケースが拡大している。

---

## 11. DEM Application Profilerとの連携

### 11.1 連携の目的

App Volumesでキャプチャしたアプリケーションの設定（ユーザープロファイル内に保存される設定）は、パッケージに含まれない。これをDEMのApplication Profilerで補完する。

### 11.2 連携ワークフロー

1. **Packaging VMにApp Volumes AgentとDEM Application Profilerをインストール**
2. **App Volumesパッケージをアタッチ**（対象アプリがVM上に出現）
3. **DEM Application Profilerを起動** > Start Session
4. **対象アプリケーションを選択して起動**
5. **アプリケーション設定を変更**（ダークモード有効化等）
6. **アプリケーションを閉じる** → Profilerが変更箇所を検出
7. **Save Config File with Predefined Settings** でエクスポート
   - Flex Configuration File（.ini）: 設定の保存場所定義
   - Predefined Settings（.zip）: 事前定義済みの設定値
8. **DEM Config Share にインポート** → DEM Management Consoleで管理

> **試験ポイント**: App Volumesパッケージはアプリケーションのバイナリ/レジストリを配信するが、ユーザープロファイル配下の設定は配信しない。DEMのPredefined Settingsで「初回ログイン時のデフォルト設定」を注入し、DirectFlexで「アプリ起動時に設定を適用」する連携が推奨パターン。

---

## 12. ベストプラクティスとアンチパターン

### ベストプラクティス

| # | プラクティス |
|---|------------|
| 1 | ADグループベースのAssignment（Marker タイプ）を標準使用 |
| 2 | CURRENTマーカーでバージョン管理し、ロールバックを容易に |
| 3 | 常時使用アプリ → Classic、たまに使用アプリ → On Demand |
| 4 | パッケージング後は必ずスナップショットに復元 |
| 5 | アプリのショートカットはPublic Desktop / Program Filesに配置 |
| 6 | DEM Application Profilerでユーザープロファイル設定を補完 |
| 7 | レプリケーションで複数サイトにパッケージを分散 |
| 8 | テスト用VMで検証後に本番Assignmentを実施 |

### アンチパターン

| # | アンチパターン | 問題点 |
|---|-------------|--------|
| 1 | 全アプリをGolden Imageに含める | イメージ肥大化、更新頻度増加 |
| 2 | Package固定でAssignment | バージョン更新時に全Assignment再設定が必要 |
| 3 | Packaging VMにHorizon Agentをインストール | 不要なキャプチャが発生 |
| 4 | パッケージング後にスナップショット復元しない | 次のキャプチャに影響 |
| 5 | 全アプリをOn Demand配信 | 起動遅延が頻発 |
| 6 | ユーザープロファイル設定をApp Volumesで対応しようとする | キャプチャされない |

---

## 13. トラブルシューティング

| 症状 | 原因候補 | 対処 |
|------|---------|------|
| パッケージがアタッチされない | Agent未インストール、Manager接続不良、Assignment未設定 | Agent状態確認、Manager URL確認、Assignment確認 |
| アプリのショートカットが表示されない | ショートカットがユーザープロファイル内 | Public Desktop / Program Filesに移動して再キャプチャ |
| パッケージングが失敗する | Packaging VMの電源OFF、Agent未登録 | VM電源ON、Agent登録確認 |
| バージョン更新後に旧バージョンが配信される | CURRENTマーカー未設定、ユーザー再ログイン未実施 | Marker確認、ユーザーにログオフ・ログインを依頼 |
| アプリ設定が保持されない | ユーザープロファイル設定がパッケージに含まれていない | DEMのApplication Profiler + Predefined Settingsで対応 |

---

## 理解度チェックリスト

- [ ] App Volumesの3層構造（Application → Package → Program）を説明できる
- [ ] パッケージング手順（Prepare → Create → Validate）を順序立てて説明できる
- [ ] CURRENTマーカーの意味とバージョン管理での活用方法を説明できる
- [ ] Assignment Type（Marker vs Package）の違いと使い分けを説明できる
- [ ] Delivery Mode（Classic vs On Demand）の違いと選択基準を説明できる
- [ ] Packaging VMの要件（App Volumes Agentのみ、Horizon Agent不要）を説明できる
- [ ] ショートカットをPublic Desktopに配置すべき理由を説明できる
- [ ] DEM Application Profilerとの連携パターンを説明できる
- [ ] Package Lifecycleのステータス遷移を説明できる
- [ ] CURRENTマーカーの移動によるロールバック手順を説明できる
- [ ] Writable VolumeとDEM Profile Archiveの違い、使い分けを説明できる
- [ ] CLI方式（appcapture.exe）のパッケージング手順と出力ファイルを説明できる
- [ ] ThinAppパッケージをApp Volumesで配信する2つの方法を説明できる
- [ ] App Volumes 2412のMSI Wrapped VHDによる物理エンドポイント配信を説明できる
